/*
函数高级

# part-1: 函数的默认参数

在C++中，函数形参列表中的形参可以有默认值，语法如下：
    返回值类型 函数名 （参数 = 默认值） {...}

如果自己传入了数据，就用自己的数据，如果没有传入，就用默认值

> 注意事项：
    1. 如果某个位置已经有了默认参数，则从这个位置往后，从左到右都必须有默认参数
    2. 如果函数声明有默认参数，函数实现就不能有默认参数，否则会触发一个错误：默认值重定义。
        声明和实现，只能有一个有默认参数。（可以写在声明里面，也可以写在实现中）

# PART-2：函数占位参数

C++函数形参列表中可以有占位参数，用来做占位，调用函数时必须填补该位置。

语法：返回值类型 函数名 (数据类型) {...}

现阶段函数展位参数存在的意义不大，但是后面的课程中会用到该技术。

# PART-3：函数重载

函数名可以相同，从而提高函数的复用性。

实现函数重载需要满足的条件：
    1. 同一个作用域下；
    2. 函数名相同；
    3. 函数参数 类型不同 或者 个数不同 或者 顺序不同。

注意：函数的返回值不可以作为函数重载的条件。

# PARRT-4：
函数重载的注意事项：
    1. 引用作为重载条件；
    2. 函数重载碰到默认参数；

*/
#include <iostream>
using namespace std;

// PART-1: 函数的默认参数
int func_sum(int a, int b = 20)
{
    return a + b;
}

// 如果函数声明已经有了默认参数，则函数实现不能有默认参数
int func_def(int a, int b = 20);
// 由于声明中已经有了默认参数，所以实现的时候不能再有默认参数
int func_def(int a, int b)
{
    return a + b;
}

// PART-2：函数占位参数
// 现阶段使用不多，也没法调用占位参数，所以仅作了解即可。
void func_place_holder(int a, int)
{
    cout << "a: " << a << endl;
}

// PART-3：函数重载
void overload_func(int a, int b)
{
    cout << "a + b: " << a + b << endl;
}
// 重载函数
void overload_func(double a, double b)
{
    cout << "a + b: " << a + b << endl;
}

// ==================== main ====================
int main(int argc, char const *argv[])
{
    // PART-1：对于有默认参数的函数，可以不传递默认参数
    cout << func_sum(10, 10) << endl; // 30

    // PART-3：函数重载
    overload_func(10, 20);     // 30
    overload_func(10.1, 20.2); // 30.3

    return 0;
}
